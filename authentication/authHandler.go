package authentication

/***********************************
authentication login status is keep in database, each record will hold user ID, login time stamp, and released hash key
Hash key is generated by server side when client login request success
Hash key will keep by client as access token; each time client send request needed to attach with the access token (hash key)
Common practice to attach hash key is by using cookies OR URL parameter
************************************/

import (
	"database/sql"
	"strings"
	"time"

	"github.com/guinso/stringtool"

	"github.com/guinso/rdbmstool"
)

const (
	//AnonymousID anonymous user ID
	AnonymousID = 0
	cookieKey   = "gorilla-goweb"
)

//LoginStatus login status
type LoginStatus uint8

const (
	//LoginSuccess login success
	LoginSuccess LoginStatus = iota
	//LoginFailed failed to login
	LoginFailed
	//AlreadyLoggedIn already logged in
	AlreadyLoggedIn
)

//LoginRequest login request information
type LoginRequest struct {
	Username string `json:"username"`
	Password string `json:"pwd"`
}

//Login try register user to login session if
//1. username and password matched
//2. no one is login
//return: login result, hash key, exception error message
func Login(db rdbmstool.DbHandlerProxy, username, password string) (LoginStatus, string, error) {
	accInfo, err := GetAccountByName(db, username)
	if err != nil {
		return LoginFailed, "", err
	}

	if accInfo == nil {
		return LoginFailed, "", err //no username found in database
	}

	if strings.Compare(accInfo.SaltedPwd, stringtool.MakeSHA256(password)) == 0 {
		now := time.Now()

		//right now is single device login session pattern
		loginStatus, hashKey, err := registerLoginSession(db, accInfo, now)
		if err != nil {
			return LoginFailed, "", err
		}

		return loginStatus, hashKey, nil
	}

	return AlreadyLoggedIn, "", nil //password not match
}

//Logout try end user login session
func Logout(db rdbmstool.DbHandlerProxy, hashKey string) (bool, error) {

	loginSession, err := getLoginSessionByHashKey(db, hashKey)
	if err != nil {
		return false, err
	}

	if loginSession == nil {
		return true, nil //make fool on potential attacker
	} else if loginSession.IsStillActive() {
		//update login session to expired
		if err = endLoginSessionByHashKey(db, hashKey); err != nil {
			return false, err
		}
	}

	return true, nil //login session already logout
}

//GetCurrentUser get current active session's user ID
//anonymous user will return nil object
func GetCurrentUser(db *sql.DB, hashKey string) (*AccountInfo, error) {
	/*
		cookie, _ := r.Cookie(cookieKey)
		if cookie == nil {
			//cookie not found; either timeout or logged out
			return nil, nil
		}
	*/

	loginSession, err := getLoginSessionByHashKey(db, hashKey)
	if err != nil {
		return nil, err //encounter  error
	}

	if loginSession == nil {
		return nil, nil //record not found (virtually not login yet)
	}

	if loginSession.IsStillActive() {
		return GetAccountByID(db, loginSession.AccountID)
	}

	return nil, nil //login session already been logged out
}
