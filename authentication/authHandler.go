package authentication

/***********************************
authentication login status is keep in database, each record will hold user ID, login time stamp, and released hash key
Hash key is generated by server side when client login request success
Hash key will keep by client as access token; each time client send request needed to attach with the access token (hash key)
Common practice to attach hash key is by using cookies OR URL parameter
************************************/

import (
	"database/sql"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/guinso/goweb/util"

	"github.com/guinso/stringtool"

	"github.com/guinso/rdbmstool"
)

const (
	//AnonymousID anonymous user ID
	AnonymousID = 0
	cookieKey   = "gorilla-goweb"
)

type loginRequest struct {
	username string `json:"username"`
	password string `json:"pwd"`
}

//HandleHTTPRequest handle incoming http request
//return true if request URL match and process
func HandleHTTPRequest(db *sql.DB, w http.ResponseWriter, r *http.Request, trimURL string) bool {
	if strings.HasPrefix(trimURL, "login") {
		var loginReq loginRequest
		err := util.DecodeJSON(r, &loginReq)
		if err != nil {
			fmt.Printf("[login] error to read user input: %s", err.Error())
			util.SendHTTPErrorResponse(w)
			return true
		}

		isSuccess, hashKey, loginErr := Login(db, loginReq.username, loginReq.password)
		if loginErr != nil {
			fmt.Printf("[login] Encounter error to attempt Login(...): %s", loginErr.Error())
			util.SendHTTPErrorResponse(w)
			return true
		}

		if !isSuccess {
			util.SendHTTPResponse(w, -1, "username or password not match", "")
			return true
		}

		//pass unique ID to cookie
		//NOTE: memory cookies can set by not providing value to property 'Expires'
		cookie := http.Cookie{
			Name:    cookieKey,
			Value:   hashKey,
			Expires: time.Now().Add(time.Hour * 2), //expire after 2 hours
		}
		http.SetCookie(w, &cookie)

		util.SendHTTPResponse(w, 0, "login success", "")
		return true

	} else if strings.HasPrefix(trimURL, "logout") {

	}

	return false
}

//Login try register user to login session if
//1. username and password matched
//2. no one is login
//return: login result, hash key, exception error message
func Login(db rdbmstool.DbHandlerProxy, username, password string) (bool, string, error) {
	accInfo, err := GetAccountByName(db, username)
	if err != nil {
		return false, "", err
	}

	if accInfo == nil {
		return false, "", err //no username found in database
	}

	if strings.Compare(accInfo.SaltedPwd, stringtool.MakeSHA256(password)) == 0 {
		now := time.Now()

		hashKey, err := registerLoginSession(db, accInfo, now)
		if err != nil {
			return false, "", err
		}
		/*
			//pass unique ID to cookie
			//NOTE: memory cookies can set by not providing value to property 'Expires'
			cookie := http.Cookie{
				Name:    cookieKey,
				Value:   hashKey,
				Expires: now.Add(time.Hour * 2), //expire after 2 hours
			}
			http.SetCookie(*w, &cookie)
		*/
		return true, hashKey, nil
	}

	return false, "", nil //password not match
}

//Logout try end user login session
func Logout(db rdbmstool.DbHandlerProxy, hashKey string) (bool, error) {

	loginSession, err := getLoginSessionByHashKey(db, hashKey)
	if err != nil {
		return false, err
	}

	if loginSession == nil {
		return true, nil
	} else if loginSession.IsStillActive() {
		//update login session to expired
		if err = endLoginSessionByHashKey(db, hashKey); err != nil {
			return false, err
		}
	}

	return true, nil //login session already logout
}

//GetCurrentUser get current active session's user ID
//anonymous user will return nil object
func GetCurrentUser(db *sql.DB, hashKey string) (*AccountInfo, error) {
	/*
		cookie, _ := r.Cookie(cookieKey)
		if cookie == nil {
			//cookie not found; either timeout or logged out
			return nil, nil
		}
	*/

	loginSession, err := getLoginSessionByHashKey(db, hashKey)
	if err != nil {
		return nil, err //encounter  error
	}

	if loginSession == nil {
		return nil, nil //record not found (virtually not login yet)
	}

	if loginSession.IsStillActive() {
		return GetAccountByID(db, loginSession.AccountID)
	}

	return nil, nil //login session already been logged out
}
